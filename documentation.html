<html>
<head>
<title>Документация по ussd</title>
<meta http-equiv="Content-Type" content="text/html; charset=koi8-r">
<link rel="stylesheet" type="text/css" href="/doc.css">
</head>

<body>
<h1>Документация по ussd версии 2.5</h1>

<fieldset>
<legend>Оглавление</legend>
<div class="toc1"><a href="#intro">Введение</a></div>
<div class="toc1"><a href="#compare">Сравнение ussd, unix-status-server и демона SNMP</a></div>
<div class="toc1"><a href="#install">Установка</a></div>
<div class="toc1"><a href="#start">Запуск и остановка</a></div>
<div class="toc1"><a href="#protocol">Протокол работы</a></div>
<div class="toc1"><a href="#command_line">Параметры командной строки</a></div>
<div class="toc1"><a href="#config_file">Файл конфигурации</a></div>
<div class="toc1"><a href="#command_list">Перечень команд</a></div>
<div class="toc2"><a href="#cmd_acpi_temperature">ACPI_TEMPERATURE</a></div>
<div class="toc2"><a href="#cmd_apache">APACHE</a></div>
<div class="toc2"><a href="#cmd_cputemp">CPUTEMP</a></div>
<div class="toc2"><a href="#cmd_debug">DEBUG</a></div>
<div class="toc2"><a href="#cmd_exec">EXEC</a></div>
<div class="toc2"><a href="#cmd_fs">FS</a></div>
<div class="toc2"><a href="#cmd_fs_list">FS_LIST</a></div>
<div class="toc2"><a href="#cmd_go">GO</a></div>
<div class="toc2"><a href="#cmd_hdd">HDD</a></div>
<div class="toc2"><a href="#cmd_hddload">HDDLOAD</a></div>
<div class="toc2"><a href="#cmd_hdd_list">HDD_LIST</a></div>
<div class="toc2"><a href="#cmd_help">HELP</a></div>
<div class="toc2"><a href="#cmd_ifaddrs">IFADDRS</a></div>
<div class="toc2"><a href="#cmd_memcache">MEMCACHE</a></div>
<div class="toc2"><a href="#cmd_netstat">NETSTAT</a></div>
<div class="toc2"><a href="#cmd_nginx">NGINX</a></div>
<div class="toc2"><a href="#cmd_pkginfo">PKGINFO</a></div>
<div class="toc2"><a href="#cmd_quit">QUIT</a></div>
<div class="toc2"><a href="#cmd_raid">RAID</a></div>
<div class="toc2"><a href="#cmd_raid_list">RAID_LIST</a></div>
<div class="toc2"><a href="#cmd_smart">SMART</a></div>
<div class="toc2"><a href="#cmd_socket">SOCKET</a></div>
<div class="toc2"><a href="#cmd_swap">SWAP</a></div>
<div class="toc2"><a href="#cmd_sysctl">SYSCTL</a></div>
<div class="toc2"><a href="#cmd_time">TIME</a></div>
<div class="toc2"><a href="#cmd_uname">UNAME</a></div>
<div class="toc2"><a href="#cmd_uptime">UPTIME</a></div>
<div class="toc2"><a href="#cmd_version">VERSION</a></div>
<div class="toc2"><a href="#cmd_vmstat">VMSTAT</a></div>
</fieldset>

<h2 class="doc"><a name="intro">Введение</a></h2>
<p><tt>ussd</tt> &mdash; демон, запускаемый на сервере под управлением FreeBSD или Linux, отвечающий на
запросы сервера мониторинга по протоколу TCP и отдающий ему различные данные для анализа и
построения графиков. <tt>ussd</tt> является следующим поколением <tt>unix-status-server</tt>
из пакета remstats и предназначен для его замены. В <tt>ussd</tt> реализована лишь часть
возможностей <tt>unix-status-server</tt>, представляющая наибольший интерес для мониторинга.
С другой стороны, в <tt>ussd</tt> учтены основные недостатки <tt>unix-status-server</tt>,
улучшена точность сбора статистики по сравнению с <tt>unix-status-server</tt>, а также
добавлены дополнительные возможности, позволяющие собирать нестандартную статистику с помощью
вызова внешних программ.

<h2 class="doc"><a name="compare">Сравнение ussd, unix-status-server и демона SNMP</a></h2>
<p>В следующей таблице представлены основные различия между <tt>ussd</tt> и
<tt>unix-status-server</tt>, а также делается их сравнение с альтернативным способом сбора
статистики &mdash; демоном SNMP (<tt>bsnmpd</tt>, <tt>net-snmp</tt> и др.).

<table class="p data">
<tr>
    <th>Критерий сравнения</th>
    <th>ussd</th>
    <th>unix-status-server</th>
    <th>Демон SNMP</th>
</tr>
<tr>
    <td>Язык реализации</td>
    <td>C</td>
    <td>Perl</td>
    <td>C</td>
</tr>
<tr>
    <td>Поддерживаемые версии FreeBSD</td>
    <td>4.x и выше</td>
    <td>4.x и выше</td>
    <td>Встроенный в систему <tt>bsnmpd</tt> появился только в версии 5.x. Пакет
<tt>net-snmp</tt> ставится из портов в любой версии FreeBSD.</td>
</tr>
<tr>
    <td>Способ запуска</td>
    <td>Демон</td>
    <td>Через суперсервер <tt>inetd</tt></td>
    <td>Демон</td>
</tr>
<tr>
    <td>Протокол передачи данных</td>
    <td>TCP</td>
    <td>TCP</td>
    <td>UDP</td>
</tr>
<tr>
    <td>Способ сбора основной статистики</td>
    <td>Вызов библиотечных функций C</td>
    <td>Вызов внешних программ и последующий парсинг результатов их вывода на
<tt>stdout</tt></td>
    <td>Вызов библиотечных функций C</td>
</tr>
<tr>
    <td>Надежность сбора основной статистики</td>
    <td>Высокая. Интерфейс вызова библиотечных функций C изменяется редко. Изменения будут
видны еще на этапе компиляции демона.</td>
    <td>Низкая. Формат вывода внешних программ часто меняется от версии к версии.
Отследить изменения форматов трудно.</td>
    <td>Высокая. Интерфейс вызова библиотечных функций C изменяется редко. Изменения будут
видны еще на этапе компиляции демона.</td>
</tr>
<tr>
    <td>Скорость работы</td>
    <td>Быстрая. Демон, написанный на С, постоянно находится в памяти и слушает TCP-порт.
Для обслуживания каждого принятого TCP-соединения создается отдельный процесс функцией
fork(2). Основная статистика отдается мгновенно, т.к. для ее сбора вызываются библиотечные
функции C. Дополнительная статистика, требующая запуска внешних программ или создания
сетевых соединений, отдается тоже достаточно быстро, т.к. собирается в параллельных
процессах.</td>
    <td>Медленная. TCP-соединения принимает демон <tt>inetd</tt>. Для обслуживания каждого
принятого TCP-соединения запускается отдельный интерпретатор Perl, который, в свою очередь,
загружает в память и выполняет скрипт <tt>unix-status-server</tt>. Любая статистика отдается
с задержкой, достигающей нескольких секунд, т.к. для сбора статистики вызываются внешние
программы.</td>
    <td>Быстрая. Демон, написанный на С, постоянно находится в памяти и слушает UDP-порт.
Основная статистика отдается мгновенно, т.к. для ее сбора вызываются библиотечные функции
C.</td>
</tr>
<tr>
    <td>Надежность работы</td>
    <td>Высокая. Основной процесс занимается только приемом TCP-соединений и периодическим
сбором статистики, которая этого требует. Обработка клиентских соединений происходит в
отдельных процессах. На каждый процесс устанавливается таймаут (сигнал SIGALRM), в результате
чего любой процесс должен рано или поздно завершиться. В коде демона нет ничего лишнего.
Работа с динамической памятью сведена к минимуму.</td>
    <td>Низкая. Код написан неаккуратно. Результат выполнения кода может различаться в
зависимости от версии Perl вплоть до полной неработоспособности. Вызов внешних программ
способен привести к вечной блокировке процесса.</td>
    <td>Низкая. Демон SNMP должен уметь отдавать статистику в соответствии со стандартами MIB.
Большая часть из этой статистики никогда не используется на практике. За счет громоздкого
кода увеличивается вероятность сбоя. Известны случаи утечек памяти при работе демона из
пакета <tt>net-snmp</tt>.</td>
</tr>
<tr>
    <td>Расширяемость</td>
    <td>В <tt>ussd</tt> предусмотрен механизм запуска внешних программ, с помощью которых
можно собирать любую нестандартную статистику. Внешние программы подключаются к <tt>ussd</tt>
с помощью конфигурационного файла и не требуют перекомпиляции или перезапуска демона.
Кроме того, сбор новой статистики можно легко добавить непосредственно в код демона,
т.к. демон является собственной разработкой компании Rambler.</td>
    <td>Сбор новой статистики можно добавить только изменив код скрипта
<tt>unix-status-server</tt>.</td>
    <td>В различных демонах SNMP существуют различные механизмы запуска внешних программ,
с помощью которых можно собирать нестандартную статистику. Изменение кода демонов SNMP
является проблематичным, т.к. для этого потребуется изучение кода, написанного сторонними
авторами.</td>
</tr>
<tr>
    <td>Поддержка 64-битных счетчиков на 32-битных платформах</td>
    <td>Да. Для получения 64-битных счетчиков интерфейсов (пакеты, байты, ошибки, коллизии)
используется периодический опрос 32-битных счетчиков (раз в секунду) и обработка их
переполнений.</td>
    <td>Нет. <tt>unix-status-server</tt> способен возвратить только то, что выводят внешние
программы. Программа <tt>netstat</tt> не поддерживает 64-битные счетчики интерфейсов на
32-битных платформах.</td>
    <td><tt>bsnmpd</tt> способен возвращать 64-битные счетчики интерфейсов начиная только
с версии FreeBSD 6.x. Метод получения 64-битных счетчиков аналогичен методу, реализованному
в <tt>ussd</tt>. <tt>net-snmp</tt> под FreeBSD не поддерживает 64-битные счетчики
интерфейсов на 32-битных платформах.</td>
</tr>
</table>

<h2 class="doc"><a name="install">Установка</a></h2>
<p><tt>ussd</tt> устанавливается утилитой <tt>install-package</tt> из пакета с исходниками.
Для всех версий FreeBSD и всех типов процессоров используется один пакет.
<tt>ussd</tt> автоматически компилируется на целевом хосте непосредственно перед установкой.
Необходимые для установки файлы находятся на
<a href="http://bsd.rambler.ru/pub/monitoring/" target=_blank>
http://bsd.rambler.ru/pub/monitoring/</a>. Пакет <tt>ussd</tt> имеет имя
<tt>ussd-&lt;version&gt;.tar.gz</tt>. Симлинк <tt>ussd.tar.gz</tt> указывает на последнюю
production версию <tt>ussd</tt>.

<p>Установку и запуск (обновление и перезапуск) <tt>ussd</tt> на целевом хосте можно
выполнить следующей последовательностью команд от пользователя <tt>root</tt>:

<pre>
fetch -pq http://bsd.rambler.ru/pub/monitoring/install-package && \
chmod +x ./install-package && \
./install-package -f uicC http://bsd.rambler.ru/pub/monitoring/ussd/ussd.tar.gz && \
/usr/local/etc/rc.d/ussd.sh restart
</pre>

<p>При установке пакет создает следующие файлы и каталоги:

<table class="layout p">
<tr><td><tt>/usr/local/sbin/ussd</tt></td></tr>
<tr><td class="lpadl">Демон <tt>ussd</tt>.</td></tr>
<tr><td class="tpad"><tt>/usr/local/etc/rc.d/ussd.sh</tt></td></tr>
<tr><td class="lpadl">Скрипт для запуска и остановки <tt>ussd</tt>.</td></tr>
<tr><td class="tpad"><tt>/usr/local/etc/ussd.conf</tt></td></tr>
<tr><td class="lpadl">Пустой файл конфигурации <tt>ussd</tt>. Создается только в том случае,
если файл отсутствует.</td></tr>
<tr><td class="tpad"><tt>/var/log/ussd.log</tt></td></tr>
<tr><td class="lpadl">Лог-файл. Создается только в том случае, если файл отсутствует.</td></tr>
<tr><td class="tpad"><tt>/var/run/uss/</tt></td></tr>
<tr><td class="lpadl">Каталог, в который будет записываться файл <tt>ussd.pid</tt> с
идентификатором процесса <tt>ussd</tt>. Каталог имеет владельца <tt>nobody</tt>.</td></tr>
</table>

<p>Кроме того, пакет обновляет список доступа к <tt>ussd</tt> в <tt>/etc/hosts.allow</tt> и
добавляет, если это необходимо, соответствующие записи в <tt>/etc/syslog.conf</tt> и
<tt>/etc/newsyslog.conf</tt> для ведения и ротации логов <tt>ussd</tt>.

<h2 class="doc"><a name="start">Запуск и остановка</a></h2>
<p>Запуск и остановка <tt>ussd</tt> производится скриптом <tt>/usr/local/etc/rc.d/ussd.sh</tt>.
Нужное действие передается скрипту первым параметром и может быть одним из следующих:

<ul>
    <li><tt>start</tt> &mdash; запуск <tt>ussd</tt> от пользователя <tt>root</tt> с
проверкой входящих соединений через систему управления доступом <tt>hosts_access(5)</tt>
и автоматическим включением технологии SMART на дисках в случае необходимости.
    <li><tt>stop</tt> &mdash; остановка <tt>ussd</tt>, если он запущен.
    <li><tt>restart</tt> &mdash; перезапуск <tt>ussd</tt>: последовательное выполнение
действий <tt>stop</tt> и <tt>start</tt> с паузой между ними в 1 секунду.
</ul>

<p>Для запуска скрипта <tt>/usr/local/etc/rc.d/ussd.sh</tt> пользователь должен иметь права
<tt>root</tt>.

<h2 class="doc"><a name="protocol">Протокол работы</a></h2>
<p>Сервер мониторинга соединяется с демоном <tt>ussd</tt>, посылает ему запрос в виде одной
или нескольких команд и ждет ответа. Каждая команда должна быть в верхнем регистре и должна
быть послана отдельной строкой. Последней должна быть команда <tt>GO</tt>. Получив команду
<tt>GO</tt>, <tt>ussd</tt> собирает запрошенную статистику, отправляет ее серверу мониторинга
и завершает соединение. Статистика представляет собой набор переменных и их значений.
Каждая переменная возвращается на отдельной строке, имеющей следующий формат:

<pre>&lt;time&gt; &lt;variable&gt; &lt;value&gt;</pre>

где <tt>&lt;time&gt;</tt> &mdash; время в формате <tt>time_t</tt>, когда было получено
значение переменной; <tt>&lt;variable&gt;</tt> &mdash; имя переменной; <tt>&lt;value&gt;</tt>
&mdash; значение переменной.

<h2 class="doc"><a name="command_line">Параметры командной строки</a></h2>
<p>Формат запуска <tt>ussd</tt>:

<pre>ussd [-ahsvL] [-c configfile] [-d level] [-p port] [-r pidfile] [-w workdir] [-u user] [-g group]</pre>

<table class="p data">
<tr>
  <th>Параметр</th>
  <th>Описание</th>
</tr>
<tr>
  <td>-a</td>
  <td>Параметр указывает, что при приеме входящих клиентских соединений нужно
руководствоваться системой управления доступом <tt>hosts_access(5)</tt> (файлы
<tt>/etc/hosts.allow</tt> и <tt>/etc/hosts.deny</tt>). Входящее соединение будет
обслуживаться только в том случае, если это разрешают правила в <tt>hosts_access(5)</tt>.</td>
</tr>
<tr>
  <td>-L</td>
  <td>Параметр указывает, что во время работы <tt>ussd</tt> не будет
периодически измерять длину очереди запросов для дисков. Это позволяет
сэкономить ресурсы процессора, но статистика по команде <tt>HDDLOAD</tt>
окажется недоступной.</td>
</tr>
<tr>
  <td>-h</td>
  <td>Выводит краткое описание параметров командной строки.</td>
</tr>
<tr>
  <td>-s</td>
  <td>Параметр указывает, что при выполнении команды <tt>SMART</tt> <tt>ussd</tt> будет
автоматически включать технологию SMART на всех дисках, на которых она поддерживается, но
не включена. При этом операционная система должна поддерживать команду прямого обращения к
дискам.</td>
</tr>
<tr>
  <td>-v</td>
  <td>Выводит номер версии <tt>ussd</tt>.</td>
</tr>
<tr>
  <td>-c configfile</td>
  <td>Имя файла конфигурации. По умолчанию: <tt>/usr/local/etc/ussd.conf</tt>.</td>
</tr>
<tr>
  <td>-d level</td>
  <td>Параметр управляет выводом отладочных сообщений. Может принимать значения
от <tt>0</tt> до <tt>2</tt>. Более высокие значения параметра соответствуют выводу большего
числа отладочных сообщений. Значение <tt>0</tt> отключает вывод отладочных сообщений.
По умолчанию: <tt>0</tt>.</td>
</tr>
<tr>
  <td>-p port</td>
  <td>TCP-порт, на котором <tt>ussd</tt> будет принимать входящие соединения.
По умолчанию: 1957.</td>
</tr>
<tr>
  <td>-r pidfile</td>
  <td>Имя файла, в который будет записываться идентификатор основного процесса (pid).
Используется для остановки <tt>ussd</tt> скриптом <tt>/usr/local/etc/rc.d/ussd.sh</tt>.
По умолчанию: <tt>/var/run/uss/ussd.pid</tt>.</td>
</tr>
<tr>
  <td>-w workdir</td>
  <td>Рабочий каталог, в который будет переходить <tt>ussd</tt> сразу после того, как станет
демоном. По умолчанию: <tt>/var/tmp</tt>.</td>
</tr>
<tr>
  <td>-u user -g group</td>
  <td>Пользователь и группа, от которых будет работать <tt>ussd</tt>. Могут быть заданы
именами или числовыми идентификаторами. <tt>ussd</tt> переключится на указанного
пользователя и группу сразу же после разбора параметров командной строки. Если группа не
задана, будет использоваться группа, в которую входит указанный пользователь.</td>
</tr>
</table>

<h2 class="doc"><a name="config_file">Файл конфигурации</a></h2>
<p>Файл конфигурации <tt>ussd</tt> является необязательным и содержит определения,
необходимые для выполнения некоторых команд. Если файл конфигурации не используется,
то для подавления предупреждений при запуске <tt>ussd</tt> рекомендуется создать на
месте файла конфигурации пустой файл. <tt>ussd</tt> перечитывает файл конфигурации при
получении сигнала SIGHUP.

<p>Файл конфигурации состоит из определений, по одному на каждой строке. Комментарии и пустые
строки игнорируются. Комментарием является любая строка, начинающаяся с символа <tt>#</tt>.

<p>В файле конфигурации допустимы следующие определения:

<pre><a name="cfg_apache">apache &lt;variable&gt; &lt;ip&gt; &lt;port&gt;</a></pre>
<div class="man-body">
<p>Указывает, что при выполнении команды <tt>APACHE</tt> нужно получить и возвратить статистику
веб-сервера Apache, слушающего на порту <tt>&lt;port&gt;</tt> ip-адреса <tt>&lt;ip&gt;</tt>.
Параметр <tt>&lt;ip&gt;</tt> предназначен для указания одного из локальных IP-адресов
многоадресного хоста в том случае, если один или несколько веб-серверов принимают запросы
только на определенных IP-адресах. Если локальный IP-адрес не важен, указывается 127.0.0.1.
Для увеличения скорости работы <tt>ussd</tt> и для обеспечения его независимости от
работоспособности DNS-серверов имена хостов не поддерживаются. Переменная
<tt>&lt;variable&gt;</tt> задает уникальное имя для веб-сервера, используемое при отдаче
статистики серверу мониторинга. Статистика Apache получается путем парсинга документа
<tt>http://&lt;ip&gt;:&lt;port&gt;/server-status?auto</tt>. Запрос к веб-серверу выполняется
по протоколу HTTP версии 1.0. Чтобы Apache отдавал статистику, в его конфигурационном файле
должны быть следующие строки:

<pre>
&lt;Location /server-status&gt;
    SetHandler server-status
    Order deny,allow
    Deny from all
    Allow from 127.0.0.1
&lt;/Location&gt;
ExtendedStatus On
</pre>

<p>Для каждого веб-сервера возвращаются следующие переменные:

<table class="p data">
<tr>
  <th>Имя переменной</th>
  <th>Тип возвращаемого значения<br>в терминах языка C</th>
  <th>Тип возвращаемого значения<br>в терминах RRDTool</th>
  <th>Описание</th>
</tr>
<tr>
  <td>apache_total_accesses:&lt;variable&gt;</td>
  <td>unsigned long long</td>
  <td>COUNTER</td>
  <td>Количество запросов к серверу.</td>
</tr>
<tr>
  <td>apache_total_kbytes:&lt;variable&gt;</td>
  <td>unsigned long long</td>
  <td>COUNTER</td>
  <td>Суммарный трафик в килобайтах.</td>
</tr>
<tr>
  <td>apache_busy_servers:&lt;variable&gt;</td>
  <td>unsigned long long</td>
  <td>GAUGE</td>
  <td>Количество работающих процессов сервера.</td>
</tr>
<tr>
  <td>apache_idle_servers:&lt;variable&gt;</td>
  <td>unsigned long long</td>
  <td>GAUGE</td>
  <td>Количество бездействующих процессов сервера.</td>
</tr>
<tr>
  <td>apache_uptime:&lt;variable&gt;</td>
  <td>unsigned long long</td>
  <td>GAUGE</td>
  <td>Время работы сервера в секундах.</td>
</tr>
</table>

<p>Поддерживается до 8 определений <tt>apache</tt>. Если не задано ни одного определения
<tt>apache</tt>, команда <tt>APACHE</tt> не возвращает ничего. Получение статистики от
всех веб-серверов происходит параллельно в отдельных процессах.
</div>

<pre><a name="cfg_nginx">nginx &lt;variable&gt; &lt;ip&gt; &lt;port&gt;</a></pre>
<div class="man-body">
<p>Указывает, что при выполнении команды <tt>NGINX</tt> нужно получить и возвратить статистику
веб-сервера nginx, слушающего на порту <tt>&lt;port&gt;</tt> ip-адреса <tt>&lt;ip&gt;</tt>.
Параметр <tt>&lt;ip&gt;</tt> предназначен для указания одного из локальных IP-адресов
многоадресного хоста в том случае, если один или несколько веб-серверов принимают запросы
только на определенных IP-адресах. Если локальный IP-адрес не важен, указывается 127.0.0.1.
Для увеличения скорости работы <tt>ussd</tt> и для обеспечения его независимости от
работоспособности DNS-серверов имена хостов не поддерживаются. Переменная
<tt>&lt;variable&gt;</tt> задает уникальное имя для веб-сервера, используемое при отдаче
статистики серверу мониторинга. Статистика nginx получается путем парсинга документа
<tt>http://&lt;ip&gt;:&lt;port&gt;/mathopd.dmp</tt>. Запрос к веб-серверу выполняется
по протоколу HTTP версии 1.0. Чтобы nginx отдавал статистику, в его конфигурационном файле
в секции "server" должны быть следующие строки:

<pre>
location = /mathopd.dmp {
    allow 127.0.0.1/32;
    deny all;
    stub_status on;
}
</pre>

<p>Для каждого веб-сервера возвращаются следующие переменные:

<table class="p data">
<tr>
  <th>Имя переменной</th>
  <th>Тип возвращаемого значения<br>в терминах языка C</th>
  <th>Тип возвращаемого значения<br>в терминах RRDTool</th>
  <th>Описание</th>
</tr>
<tr>
  <td>nginx_accepts:&lt;variable&gt;</td>
  <td>unsigned long long</td>
  <td>COUNTER</td>
  <td>Количество соединений, принятых сервером через вызов функции accept().</td>
</tr>
<tr>
  <td>nginx_handled:&lt;variable&gt;</td>
  <td>unsigned long long</td>
  <td>COUNTER</td>
  <td>Количество соединений, обработанных сервером, а не закрытых сразу. Соединение
сразу закрывается, если таблица соединений переполнена.</td>
</tr>
<tr>
  <td>nginx_requests:&lt;variable&gt;</td>
  <td>unsigned long long</td>
  <td>COUNTER</td>
  <td>Количество запросов, обслуженных сервером. В одном keep-alive соединении может
быть несколько запросов.</td>
</tr>
<tr>
  <td>nginx_active:&lt;variable&gt;</td>
  <td>unsigned long long</td>
  <td>GAUGE</td>
  <td>Количество всех активных соединений с сервером в момент опроса. Равно сумме
<tt>nginx_reading</tt>, <tt>nginx_writing</tt> и <tt>nginx_waiting</tt>.</td>
</tr>
<tr>
  <td>nginx_reading:&lt;variable&gt;</td>
  <td>unsigned long long</td>
  <td>GAUGE</td>
  <td>Количество активных соединений с сервером, находящихся в момент опроса в состоянии
чтения.</td>
</tr>
<tr>
  <td>nginx_writing:&lt;variable&gt;</td>
  <td>unsigned long long</td>
  <td>GAUGE</td>
  <td>Количество активных соединений с сервером, находящихся в момент опроса в состоянии
записи (заголовок запроса уже прочитан, но отдача ответа еще не завершена).</td>
</tr>
<tr>
  <td>nginx_waiting:&lt;variable&gt;</td>
  <td>unsigned long long</td>
  <td>GAUGE</td>
  <td>Количество активных соединений с сервером, находящихся в момент опроса в состоянии
ожидания.</td>
</tr>
</table>

<p>Поддерживается до 8 определений <tt>nginx</tt>. Если не задано ни одного определения
<tt>nginx</tt>, команда <tt>NGINX</tt> не возвращает ничего. Получение статистики от
всех веб-серверов происходит параллельно в отдельных процессах.
</div>

<pre><a name="cfg_memcache">memcache &lt;variable&gt; &lt;ip&gt; &lt;port&gt;</a></pre>
<div class="man-body">
<p>Указывает, что при выполнении команды <tt>MEMCACHE</tt> нужно получить и возвратить
статистику демона <tt>memcached</tt>, слушающего на порту <tt>&lt;port&gt;</tt>
ip-адреса <tt>&lt;ip&gt;</tt>. Параметр <tt>&lt;ip&gt;</tt> предназначен для указания
одного из локальных IP-адресов многоадресного хоста в том случае, если один или несколько
демонов <tt>memcached</tt> принимают запросы только на определенных IP-адресах. Если
локальный IP-адрес не важен, указывается 127.0.0.1. Для увеличения скорости работы
<tt>ussd</tt> и для обеспечения его независимости от работоспособности DNS-серверов имена
хостов не поддерживаются. Переменная <tt>&lt;variable&gt;</tt> задает уникальное имя для
демона <tt>memcached</tt>, используемое при отдаче статистики серверу мониторинга. Для сбора
статистики <tt>ussd</tt> соединяется с сервером <tt>memcached</tt>, посылает ему команду
<tt>stats</tt> и осуществляет парсинг ответа. Серверу мониторинга отдаются все переменные
<tt>memcached</tt>, преобразованные к виду
<tt>memcache_&lt;memcache_variable&gt;:&lt;variable&gt;</tt>, где
<tt>&lt;memcache_variable&gt;</tt> &mdash; оригинальное имя переменной, возвращаемое
<tt>memcached</tt>. Значения переменных не анализируются и отдаются как есть. Поддерживается
до 64 определений <tt>memcache</tt>. Если не задано ни одного определения <tt>memcache</tt>,
команда <tt>MEMCACHE</tt> не возвращает ничего. Получение статистики от всех демонов
<tt>memcached</tt> происходит параллельно в отдельных процессах.
</div>

<pre><a name="cfg_exec">exec &lt;command&gt;</a></pre>
<div class="man-body">
<p>Указывает, что при выполнении команды <tt>EXEC</tt> нужно возвратить статистику, полученную
от внешней программы <tt>&lt;command&gt;</tt>. <tt>&lt;command&gt;</tt> может быть именем
файла или любой допустимой командой языка <tt>sh</tt>. Для сбора статистики <tt>ussd</tt>
запускает внешнюю программу и осуществляет парсинг строк, которые программа выводит на
свой <tt>stdout</tt>. Внешняя программа должна выводить статистику по одной переменной
на каждой строке. Строки должны иметь следующий формат:

<pre>&lt;command_variable&gt; &lt;value&gt;</pre>

<p>Строки с неверным форматом игнорируются. Имена переменных <tt>&lt;command_variable&gt;</tt>
переводятся в нижний регистр. Серверу мониторинга отдаются все переменные внешней программы,
преобразованные к виду <tt>exec_&lt;command_variable&gt;</tt>. Значения переменных не
анализируются и отдаются как есть. Поддерживается до 16 определений <tt>exec</tt>. Если не
задано ни одного определения <tt>exec</tt>, команда <tt>EXEC</tt> не возвращает ничего.
Получение статистики от всех внешних программ происходит параллельно в отдельных процессах.
Если внешняя программа не завершается спустя отведенное ей время, всей группе процессов,
связанной с выполнением данной внешней программы, посылается сигнал SIGKILL. Для корректной
работы автоматического завершения группы процессов на внешнюю программу накладывается
ограничение: она не должна изменять свой идентификатор группы процессов (pgid).
</div>

<pre><a name="cfg_socket">socket &lt;variable&gt; &lt;proto&gt; &lt;address&gt;</a></pre>
<div class="man-body">
<p>Указывает, что <tt>ussd</tt> будет следить за сокетом протокола <tt>&lt;proto&gt;</tt>
слушающего по адресу <tt>&lt;address&gt;</tt> и возвращать его статистику
при выполнении команды <tt>SOCKET</tt>. Поддерживаются следующие протоколы:
<table class="p data">
<tr>
  <th>proto</th>
  <th>Семейство адресов</th>
  <th>Вид адреса</th>
</tr>
<tr>
  <td>tcp</td>
  <td class="calign" rowspan="2">IP</td>
  <td class="calign" rowspan="2">&lt;ip&gt;&nbsp&lt;port&gt;</td>
</tr>
<tr>
  <td>udp</td>
</tr>
<tr>
  <td>tcp6</td>
  <td class="calign" rowspan="2">IPv6</td>
  <td class="calign" rowspan="2">&lt;ip&gt;&nbsp&lt;port&gt;</td>
</tr>
<tr>
  <td>udp6</td>
</tr>
<tr>
  <td>unix</td>
  <td class="calign">LOCAL</td>
  <td>&lt;path&gt;</td>
</tr>
</table>
Для сокетов которые слушают все ip-адреса допустимо указывать в поле &lt;ip&gt; '*' (звёздочку).<br>
Для каждого сокета возвращаются следующие переменные:
<table class="p data">
<tr>
  <th>Имя переменной</th>
  <th>Тип возвращаемого значения<br>в терминах языка C</th>
  <th>Тип возвращаемого значения<br>в терминах RRDTool</th>
  <th>Описание</th>
</tr>
<tr>
  <td>socket_exist:&lt;variable&gt;</td>
  <td>uint8_t (значим 1 младший бит)</td>
  <td>GAUGE</td>
  <td>Наличие слушающего сокета</td>
</tr>
<tr>
  <td>socket_queue_receive_limit:&lt;variable&gt;</td>
  <td>int</td>
  <td>GAUGE</td>
  <td>Ограничение на размер очереди запросов</td>
</tr>
<tr>
  <td>socket_queue_receive_length:&lt;variable&gt;</td>
  <td>int</td>
  <td>GAUGE</td>
  <td>Текущий размер очереди запросов</td>
</tr>
<tr>
  <td>socket_queue_receive_inclength:&lt;variable&gt;</td>
  <td>int</td>
  <td>GAUGE</td>
  <td>Текущий размер очереди запросов до accept_filter(9)</td>
</tr>
<tr>
  <td>socket_queue_receive_load_average:&lt;variable&gt;</td>
  <td>double</td>
  <td>GAUGE</td>
  <td>Средний размер очереди запросов</td>
</tr>
<tr>
  <td>socket_queue_receive_peak_max:&lt;variable&gt;</td>
  <td>int</td>
  <td>GAUGE</td>
  <td>Пиковый размер очереди запросов</td>
</tr>
</table>
Поддерживается до 64 определений <tt>socket</tt>. Если не задано ни одного
определения <tt>socket</tt>, команда <tt>SOCKET</tt> не возвращает ничего.
</div>

<pre><a name="cfg_sock_la_interval">sock_la_interval &lt;seconds&gt;</a></pre>
<div class="man-body">
<p>Определяет интервал опроса состояния сокетов в секундах. Увеличение этого интервала
экономит время процессора (на Linux или в случае когда не все сокеты существуют) но
уменьшает точность статистики.
</div>

<pre><a name="cfg_no_smart_enable">no_smart_enable</a></pre>
<div class="man-body">
<p>Указывает, что при выполнении команды <tt>SMART</tt> <tt>ussd</tt> не будет автоматически
включать технологию SMART на дисках, на которых она не включена, даже если <tt>ussd</tt>
запущен с параметром командной строки <tt>-s</tt>.
</div>

<pre><a name="cfg_no_hdds_la">no_hdds_la</a></pre>
<div class="man-body">
<p>Указывает, что во время работы <tt>ussd</tt> не будет
периодически измерять длину очереди запросов для дисков.
</div>

<pre><a name="cfg_no_p2p_interfaces">no_p2p_interfaces</a></pre>
<div class="man-body">
<p>Указывает, что при выполнении команды <tt>NETSTAT</tt> <tt>ussd</tt> не будет сообщать
статистику интерфейсов типа точка-точка.
</div>

<h2 class="doc"><a name="command_list">Перечень команд</a></h2>
<p><tt>ussd</tt> поддерживает следующие команды (в алфавитном порядке):

<h3 class="man-title"><a name="cmd_acpi_temperature"><tt>ACPI_TEMPERATURE</tt></a></h3>
<div class="man-body">
Возвращает температуру всех тепловых зон ACPI. Если в системе нет ни одной тепловой зоны
ACPI или ACPI не поддерживается, не возвращает ничего.

<table class="p data">
<tr>
  <th>Имя переменной</th>
  <th>Тип возвращаемого значения<br>в терминах языка C</th>
  <th>Тип возвращаемого значения<br>в терминах RRDTool</th>
  <th>Описание</th>
</tr>
<tr>
  <td>acpi_temperature:tz&lt;thermal_zone&gt;</td>
  <td>double (%.0f)</td>
  <td>GAUGE</td>
  <td>Температура тепловой зоны ACPI в градусах Цельсия.</td>
</tr>
</table>

<div><tt>&lt;thermal_zone&gt;</tt> &mdash; номер тепловой зоны ACPI, начиная с нуля.</div>
</div>

<h3 class="man-title"><a name="cmd_apache"><tt>APACHE</tt></a></h3>
<div class="man-body">
Возвращает статистику веб-серверов Apache. Подробности использования команды описаны в
разделе <a href="#cfg_apache">Файл конфигурации</a>.
</div>

<h3 class="man-title"><a name="cmd_debug"><tt>DEBUG &lt;level&gt;</tt></a></h3>
<div class="man-body">
Управляет выводом отладочных сообщений. Параметр <tt>&lt;level&gt;</tt> может принимать
значения от <tt>0</tt> до <tt>2</tt>. Более высокие значения параметра соответствуют выводу
большего числа отладочных сообщений. Значение <tt>0</tt> отключает вывод отладочных сообщений.
Данная команда имеет больший приоритет, чем параметр командной строки <tt>-d</tt>. Действие
команды распространяется только на текущее TCP-соединение.
</div>

<h3 class="man-title"><a name="cmd_cputemp"><tt>CPUTEMP</tt></a></h3>
<div class="man-body">
Возвращает среднюю температуру всех имеющихся процессоров. Если в системе недоступны температуры
процессоров, не возвращает ничего.

<table class="p data">
<tr>
  <th>Имя переменной</th>
  <th>Тип возвращаемого значения<br>в терминах языка C</th>
  <th>Тип возвращаемого значения<br>в терминах RRDTool</th>
  <th>Описание</th>
</tr>
<tr>
  <td>cputemp_average</td>
  <td>double</td>
  <td>GAUGE</td>
  <td>Средняя температура процессоров в градусах Цельсия.</td>
</tr>
<tr>
  <td>cputemp_minimum</td>
  <td>double</td>
  <td>GAUGE</td>
  <td>Минимальная температура процессоров в градусах Цельсия.</td>
</tr>
<tr>
  <td>cputemp_maximum</td>
  <td>double</td>
  <td>GAUGE</td>
  <td>Максимальная температура процессоров в градусах Цельсия.</td>
</tr>
</table>
</div>

<h3 class="man-title"><a name="cmd_exec"><tt>EXEC</tt></a></h3>
<div class="man-body">
Возвращает статистику, полученную от внешних программ. Подробности использования команды
описаны в разделе <a href="#cfg_exec">Файл конфигурации</a>.
</div>

<h3 class="man-title"><a name="cmd_fs"><tt>FS</tt></a></h3>
<div class="man-body">
Возвращает статистику файловых систем. Для каждой файловой системы возвращается ее общий
размер в килобайтах, размер свободного и занятого места в килобайтах, общее число инодов,
а также число свободных и занятых инодов. Файловые системы с типом, отличным от UFS или ZFS,
игнорируются.

<table class="p data">
<tr>
  <th>Имя переменной</th>
  <th>Тип возвращаемого значения<br>в терминах языка C</th>
  <th>Тип возвращаемого значения<br>в терминах RRDTool</th>
  <th>Описание</th>
</tr>
<tr>
  <td>fs_space_size:&lt;mntname&gt;</td>
  <td>long long</td>
  <td>GAUGE</td>
  <td>Физический размер файловой системы в килобайтах. Всегда неотрицателен.</td>
</tr>
<tr>
  <td>fs_space_size_avail:&lt;mntname&gt;</td>
  <td>long long</td>
  <td>GAUGE</td>
  <td>Размер файловой системы в килобайтах, доступный для непривелегированных пользователей.
Всегда неотрицателен. Обычно меньше параметра <tt>fs_space_size</tt> на 8%.</td>
</tr>
<tr>
  <td>fs_space_free:&lt;mntname&gt;</td>
  <td>long long</td>
  <td>GAUGE</td>
  <td>Физический размер свободного места на файловой системе в килобайтах. Всегда
неотрицателен. Сумма <tt>fs_space_used</tt> и <tt>fs_space_free</tt> всегда равна
<tt>fs_space_size</tt>.</td>
</tr>
<tr>
  <td>fs_space_free_avail:&lt;mntname&gt;</td>
  <td>long long</td>
  <td>GAUGE</td>
  <td>Размер свободного места на файловой системе в килобайтах, доступный для
непривелегированных пользователей. Может быть отрицательным в том случае, если на файловой
системе занято больше места, чем указано в параметре <tt>fs_space_size_avail</tt>. Сумма
<tt>fs_space_used</tt> и <tt>fs_space_free_avail</tt> всегда равна
<tt>fs_space_size_avail</tt>.</td>
</tr>
<tr>
  <td>fs_space_used:&lt;mntname&gt;</td>
  <td>long long</td>
  <td>GAUGE</td>
  <td>Размер занятого места на файловой системе в килобайтах. Всегда неотрицателен.</td>
</tr>
<tr>
  <td>fs_space_used_ratio:&lt;mntname&gt;</td>
  <td>double (%.0f)</td>
  <td>GAUGE</td>
  <td>Процент занятости места на файловой системе с точки зрения непривелегированного
пользователя. Всегда неотрицателен. Может быть больше 100, если параметр <tt>fs_space_used</tt>
больше параметра <tt>fs_space_size_avail</tt>.</td>
</tr>
<tr>
  <td>fs_inodes_size:&lt;mntname&gt;</td>
  <td>long</td>
  <td>GAUGE</td>
  <td>Физическое число инодов на файловой системе. Всегда неотрицательно.</td>
</tr>
<tr>
  <td>fs_inodes_free:&lt;mntname&gt;</td>
  <td>long</td>
  <td>GAUGE</td>
  <td>Число свободных инодов на файловой системе. Всегда неотрицательно. Сумма
<tt>fs_inodes_used</tt> и <tt>fs_inodes_free</tt> всегда равна <tt>fs_inodes_size</tt>.</td>
</tr>
<tr>
  <td>fs_inodes_used:&lt;mntname&gt;</td>
  <td>long</td>
  <td>GAUGE</td>
  <td>Число занятых инодов на файловой системе. Всегда неотрицательно.</td>
</tr>
<tr>
  <td>fs_inodes_used_ratio:&lt;mntname&gt;</td>
  <td>double (%.0f)</td>
  <td>GAUGE</td>
  <td>Процент использования инодов на файловой системе. Всегда неотрицателен. Всегда
меньше либо равен 100.</td>
</tr>
</table>

<div><tt>&lt;mntname&gt;</tt> &mdash; точка монтирования файловой системы.</div>
</div>

<h3 class="man-title"><a name="cmd_fs_list"><tt>FS_LIST</tt></a></h3>
<div class="man-body">
Возвращает список всех файловых систем. Файловые системы с типом, отличным от UFS или ZFS,
игнорируются.

<table class="p data">
<tr>
  <th>Имя переменной</th>
  <th>Тип возвращаемого значения<br>в терминах языка C</th>
  <th>Тип возвращаемого значения<br>в терминах RRDTool</th>
  <th>Описание</th>
</tr>
<tr>
  <td>fs_exists:&lt;mntname&gt;</td>
  <td>uint8_t (значим 1 младший бит)</td>
  <td>GAUGE</td>
  <td>Значение переменной всегда равно 1. Наличие переменной означает, что файловая
система с точкой монтирования <tt>&lt;mntname&gt;</tt> существует.</td>
</tr>
</table>
</div>

<h3 class="man-title"><a name="cmd_go"><tt>GO</tt></a></h3>
<div class="man-body">
Команда, сигнализирующая о конце запроса. При получении этой команды <tt>ussd</tt> собирает
запрошенную статистику, отдает ее серверу мониторинга и завершает соединение. Все команды,
идущие после <tt>GO</tt>, игнорируются.
</div>

<h3 class="man-title"><a name="cmd_hdd"><tt>HDD</tt></a></h3>
<div class="man-body">
Возвращает статистику жестких дисков ATA/SATA/SCSI. Для каждого диска возвращается название модели,
серийный номер и версия прошивки, размер диска в секторах и мегабайтах, время, в течение которого
диск был занят выполнением различных операций, количество считанных, записанных и удаленных
байтов.

<table class="p data">
<tr>
  <th>Имя переменной</th>
  <th>Тип возвращаемого значения<br>в терминах языка C</th>
  <th>Тип возвращаемого значения<br>в терминах RRDTool</th>
  <th>Описание</th>
</tr>
<tr>
  <td>ata_request_supported</td>
  <td>uint8_t (значим 1 младший бит)</td>
  <td>GAUGE</td>
  <td>Флаг, показывающий, что операционная система поддерживает (1) или не поддерживает
(0) команду прямого обращения к диску. Только с помощью этой команды можно получить
текущие параметры диска гарантированно минуя кэш операционной системы, а также прочитать
атрибуты SMART.</td>
</tr>
<tr>
  <td>hdd_model:&lt;hdd&gt;</td>
  <td>char[40] не включая null</td>
  <td>&ndash;</td>
  <td>Модель диска.</td>
</tr>
<tr>
  <td>hdd_serno:&lt;hdd&gt;</td>
  <td>char[20] не включая null</td>
  <td>&ndash;</td>
  <td>Серийный номер диска.</td>
</tr>
<tr>
  <td>hdd_revision:&lt;hdd&gt;</td>
  <td>char[8] не включая null</td>
  <td>&ndash;</td>
  <td>Версия прошивки диска.</td>
</tr>
<tr>
  <td>hdd_size_sectors:&lt;hdd&gt;</td>
  <td>uint64_t</td>
  <td>GAUGE</td>
  <td>Точный размер диска в секторах.</td>
</tr>
<tr>
  <td>hdd_size_mbytes:&lt;hdd&gt;</td>
  <td>uint64_t (значимы 53 младших бита)</td>
  <td>GAUGE</td>
  <td>Округленный до целого размер диска в мегабайтах.</td>
</tr>
<tr>
  <td>hdd_busy_time:&lt;hdd&gt;</td>
  <td>unsigned long</td>
  <td>COUNTER</td>
  <td>Время в секундах, в течение которого диск был занят выполнением различных операций.</td>
</tr>
<tr>
  <td>hdd_bytes_read:&lt;hdd&gt;</td>
  <td>uint64_t</td>
  <td>DERIVE</td>
  <td>Количество считанных с диска байтов.</td>
</tr>
<tr>
  <td>hdd_bytes_written:&lt;hdd&gt;</td>
  <td>uint64_t</td>
  <td>DERIVE</td>
  <td>Количество записанных на диск байтов.</td>
</tr>
<tr>
  <td>hdd_bytes_deleted:&lt;hdd&gt;</td>
  <td>uint64_t</td>
  <td>DERIVE</td>
  <td>Количество удаленных с диска байтов.</td>
</tr>
</table>

<div><tt>&lt;hdd&gt;</tt> &mdash; имя жесткого диска в системе.</div>
</div>

<h3 class="man-title"><a name="cmd_hddload"><tt>HDDLOAD</tt></a></h3>
<div class="man-body">
Возвращает среднюю длину очереди команд дисков ATA/SATA/SCSI.

<table class="p data">
<tr>
  <th>Имя переменной</th>
  <th>Тип возвращаемого значения<br>в терминах языка C</th>
  <th>Тип возвращаемого значения<br>в терминах RRDTool</th>
  <th>Описание</th>
</tr>
<tr>
  <td>hdd_load5:&lt;hdd&gt;</td>
  <td>double (%0.2f)</td>
  <td>GAUGE</td>
  <td>Средняя за 5 минут длина очереди команд.</td>
</tr>
<tr>
  <td>hdd_load15:&lt;hdd&gt;</td>
  <td>double (%0.2f)</td>
  <td>GAUGE</td>
  <td>Средняя за 15 минут длина очереди команд.</td>
</tr>
</table>
</div>

<h3 class="man-title"><a name="cmd_hdd_list"><tt>HDD_LIST</tt></a></h3>
<div class="man-body">
Возвращает список всех жестких дисков ATA/SATA/SCSI.

<table class="p data">
<tr>
  <th>Имя переменной</th>
  <th>Тип возвращаемого значения<br>в терминах языка C</th>
  <th>Тип возвращаемого значения<br>в терминах RRDTool</th>
  <th>Описание</th>
</tr>
<tr>
  <td>hdd_exists:&lt;hdd&gt;</td>
  <td>uint8_t (значим 1 младший бит)</td>
  <td>GAUGE</td>
  <td>Значение переменной всегда равно 1. Наличие переменной означает, что жесткий диск
с именем <tt>&lt;hdd&gt;</tt> существует.</td>
</tr>
</table>
</div>

<h3 class="man-title"><a name="cmd_help"><tt>HELP</tt></a></h3>
<div class="man-body">
Выводит информацию о версии <tt>ussd</tt> и перечень поддерживаемых команд. Команда
предназначена для интерактивного использования и выполняется сразу после получения.
</div>

<h3 class="man-title"><a name="cmd_ifaddrs"><tt>IFADDRS</tt></a></h3>
<div class="man-body">
Возвращает адреса интерфейсов. Интерфейсы типа LOOPBACK игнорируются.

<table class="p data">
<tr>
  <th>Имя переменной</th>
  <th>Тип возвращаемого значения<br>в терминах языка C</th>
  <th>Тип возвращаемого значения<br>в терминах RRDTool</th>
  <th>Описание</th>
</tr>
<tr>
  <td>interface_ether:&lt;ifname&gt;</td>
  <td>char[]</td>
  <td>-</td>
  <td>Ethernet (MAC) адрес.</td>
</tr>
<tr>
  <td>interface_inet:&lt;ifname&gt;</td>
  <td>char[]</td>
  <td>-</td>
  <td>IP-адрес.</td>
</tr>
<tr>
  <td>interface_inet6:&lt;ifname&gt;</td>
  <td>char[]</td>
  <td>-</td>
  <td>IPv6-адрес.</td>
</tr>
</table>

<div><tt>&lt;ifname&gt;</tt> &mdash; имя интерфейса.</div>
</div>

<h3 class="man-title"><a name="cmd_memcache"><tt>MEMCACHE</tt></a></h3>
<div class="man-body">
Возвращает статистику демонов <tt>memcached</tt>. Подробности использования команды
описаны в разделе <a href="#cfg_memcache">Файл конфигурации</a>.
</div>

<h3 class="man-title"><a name="cmd_netstat"><tt>NETSTAT</tt></a></h3>
<div class="man-body">
Возвращает статистику интерфейсов. Для каждого интерфейса в системе возвращается число
принятых и отправленных пакетов, число принятых и отправленных байтов, число ошибок приема,
передачи, а также число коллизий. Все возвращаемые значения 64-битные. Интерфейсы типа
LOOPBACK, а также интерфейсы в состоянии DOWN игнорируются. Интерфейсы типа точка-точка тоже обычно игнорируются (подробности описаны в разделе <a href="#cfg_no_p2p_interfaces">Файл конфигурации</a>).

<table class="p data">
<tr>
  <th>Имя переменной</th>
  <th>Тип возвращаемого значения<br>в терминах языка C</th>
  <th>Тип возвращаемого значения<br>в терминах RRDTool</th>
  <th>Описание</th>
</tr>
<tr>
  <td>interface_packets_in:&lt;ifname&gt;</td>
  <td>unsigned long long</td>
  <td>DERIVE</td>
  <td>Число принятых пакетов.</td>
</tr>
<tr>
  <td>interface_bytes_in:&lt;ifname&gt;</td>
  <td>unsigned long long</td>
  <td>DERIVE</td>
  <td>Число принятых байтов.</td>
</tr>
<tr>
  <td>interface_errors_in:&lt;ifname&gt;</td>
  <td>unsigned long long</td>
  <td>DERIVE</td>
  <td>Число ошибок приема данных.</td>
</tr>
<tr>
  <td>interface_packets_out:&lt;ifname&gt;</td>
  <td>unsigned long long</td>
  <td>DERIVE</td>
  <td>Число отправленных пакетов.</td>
</tr>
<tr>
  <td>interface_bytes_out:&lt;ifname&gt;</td>
  <td>unsigned long long</td>
  <td>DERIVE</td>
  <td>Число отправленных байтов.</td>
</tr>
<tr>
  <td>interface_errors_out:&lt;ifname&gt;</td>
  <td>unsigned long long</td>
  <td>DERIVE</td>
  <td>Число ошибок передачи данных.</td>
</tr>
<tr>
  <td>interface_collisions:&lt;ifname&gt;</td>
  <td>unsigned long long</td>
  <td>DERIVE</td>
  <td>Число коллизий.</td>
</tr>
</table>

<div><tt>&lt;ifname&gt;</tt> &mdash; имя интерфейса.</div>
</div>

<h3 class="man-title"><a name="cmd_nginx"><tt>NGINX</tt></a></h3>
<div class="man-body">
Возвращает статистику веб-серверов nginx. Подробности использования команды описаны в
разделе <a href="#cfg_nginx">Файл конфигурации</a>.
</div>

<h3 class="man-title"><a name="cmd_pkginfo"><tt>PKGINFO</tt></a></h3>
<div class="man-body">
Возвращает информацию об установленных пакетах FreeBSD. В Linux не возвращает ничего.

<table class="p data">
<tr>
  <th>Имя переменной</th>
  <th>Тип возвращаемого значения<br>в терминах языка C</th>
  <th>Тип возвращаемого значения<br>в терминах RRDTool</th>
  <th>Описание</th>
</tr>
<tr>
  <td>pkg_exist:&lt;pkgname&gt;</td>
  <td>uint8_t (значим 1 младший бит)</td>
  <td>GAUGE</td>
  <td>Значение переменной всегда равно 1. Наличие переменной означает, что
информация о пакете &lt;pkgname&gt; доступна.
</tr>
<tr>
  <td>pkg_ctime:&lt;pkgname&gt;</td>
  <td>unsigned long</td>
  <td>GAUGE</td>
  <td>Время установки пакета в формате UNIX-time</td>
</tr>
<tr>
  <td>pkg_origin:&lt;pkgname&gt;</td>
  <td>char[]</td>
  <td>-</td>
  <td>Имя порта, из которого собран установленный пакет</td>
</tr>
<tr>
  <td>pkg_count</td>
  <td>unsigned</td>
  <td>GAUGE</td>
  <td>Общее количества установленных пакетов (маркер конца списка)</td>
</tr>
</table>
<div><tt>&lt;pkgname&gt;</tt> &mdash; имя установленного пакета в системе.</div>
</div>

<h3 class="man-title"><a name="cmd_quit"><tt>QUIT</tt></a></h3>
<div class="man-body">
Завершает соединение без сбора и возврата статистики. Команда предназначена для
интерактивного использования и выполняется сразу после получения.
</div>

<h3 class="man-title"><a name="cmd_raid"><tt>RAID</tt></a></h3>
<div class="man-body">
Возвращает статистику RAID-массивов. Поддерживаются RAID-массивы, построенные с
использованием модели GEOM (классы MIRROR, STRIPE и CONCAT). Для каждого RAID-массива возвращается
его состояние (разрушен или нет).

<table class="p data">
<tr>
  <th>Имя переменной</th>
  <th>Тип возвращаемого значения<br>в терминах языка C</th>
  <th>Тип возвращаемого значения<br>в терминах RRDTool</th>
  <th>Описание</th>
</tr>
<tr>
  <td>raid_state:&lt;raid&gt;</td>
  <td>char[]</td>
  <td>&ndash;</td>
  <td>Состояние RAID-массива в текстовом виде так, как его возвращает операционная система.
Переменная может отсутствовать, если операционная система не возвращает состояние
RAID-массива.</td>
</tr>
<tr>
  <td>raid_state_error:&lt;raid&gt;</td>
  <td>uint8_t</td>
  <td>GAUGE</td>
  <td>Переменная, сигнализирующая об ошибочном состоянии RAID-массива. Может принимать
три значения: 0 &mdash; нормальное состояние RAID-массива; 1 &mdash; RAID-массив разрушен,
но запущена его синхронизация; 2 &mdash; RAID-массив разрушен и синхронизация не запущена.
Переменная определена всегда.</td>
</tr>
</table>

<div><tt>&lt;raid&gt;</tt> &mdash; имя RAID-массива в системе.</div>
</div>

<h3 class="man-title"><a name="cmd_raid_list"><tt>RAID_LIST</tt></a></h3>
<div class="man-body">
Возвращает список всех RAID-массивов. Поддерживаются RAID-массивы, построенные с
использованием модели GEOM (классы MIRROR, STRIPE и CONCAT).

<table class="p data">
<tr>
  <th>Имя переменной</th>
  <th>Тип возвращаемого значения<br>в терминах языка C</th>
  <th>Тип возвращаемого значения<br>в терминах RRDTool</th>
  <th>Описание</th>
</tr>
<tr>
  <td>raid_exists:&lt;raid&gt;</td>
  <td>uint8_t (значим 1 младший бит)</td>
  <td>GAUGE</td>
  <td>Значение переменной всегда равно 1. Наличие переменной означает, что RAID-массив
с именем <tt>&lt;raid&gt;</tt> существует.</td>
</tr>
</table>
</div>

<h3 class="man-title"><a name="cmd_smart"><tt>SMART [&lt;attribute&gt;|ALL]</tt></a></h3>
<div class="man-body">
Возвращает атрибуты SMART жестких дисков ATA/SATA. Если диск поддерживает технологию SMART,
технология SMART включена на данном диске и операционная система поддерживает получение
информации по этой технологии, возвращаются все или некоторые атрибуты SMART данного диска
в зависимости от формата команды. Если была введена команда <tt>SMART ALL</tt>, возвращаются
все атрибуты SMART по каждому диску. Если была введена команда
<tt>SMART &lt;attribute&gt;</tt>, где <tt>&lt;attribute&gt;</tt> &mdash; десятичный номер
атрибута SMART от 0 до 255, то возвращается только запрошенный атрибут по каждому диску,
если он поддерживается дисками. Команда <tt>SMART &lt;attribute&gt;</tt> может быть введена
несколько раз с разными значениями <tt>&lt;attribute&gt;</tt> для получения информации
по нескольким атрибутам. Если была введена команда <tt>SMART</tt> без параметров,
возвращается только общая информация о дисках, а запрос по технологии SMART не производится
вообще.

<p>Следующие переменные возвращаются при любом формате ввода команды <tt>SMART</tt>:

<table class="p data">
<tr>
  <th>Имя переменной</th>
  <th>Тип возвращаемого значения<br>в терминах языка C</th>
  <th>Тип возвращаемого значения<br>в терминах RRDTool</th>
  <th>Описание</th>
</tr>
<tr>
  <td>ata_request_supported</td>
  <td>uint8_t (значим 1 младший бит)</td>
  <td>GAUGE</td>
  <td>Флаг, показывающий, что операционная система поддерживает (1) или не поддерживает (0)
команду прямого обращения к диску. Только с помощью этой команды можно получить текущие
параметры диска гарантированно минуя кэш операционной системы, а также прочитать атрибуты
SMART.</td>
</tr>
<tr>
  <td>smart_supported:&lt;hdd&gt;</td>
  <td>uint8_t (значим 1 младший бит)</td>
  <td>GAUGE</td>
  <td>Флаг, показывающий, что диск поддерживает (1) или не поддерживает (0) технологию
SMART.</td>
</tr>
<tr>
  <td>smart_enabled:&lt;hdd&gt;</td>
  <td>uint8_t (значим 1 младший бит)</td>
  <td>GAUGE</td>
  <td>Флаг, показывающий, что технология SMART включена (1) или выключена (0) на данном
диске. Значение 1 может быть только в том случае, если диск поддерживает технологию
SMART.</td>
</tr>
</table>

<p>Следующие переменные возвращаются только в том случае, если запрошены соответствующие
атрибуты SMART:

<table class="p data">
<tr>
  <th>Имя переменной</th>
  <th>Тип возвращаемого значения<br>в терминах языка C</th>
  <th>Тип возвращаемого значения<br>в терминах RRDTool</th>
  <th>Описание</th>
</tr>
<tr>
  <td>smart_&lt;attribute&gt;_flags:&lt;hdd&gt;</td>
  <td>uint8_t</td>
  <td>GAUGE</td>
  <td>Набор флагов атрибута SMART.</td>
</tr>
<tr>
  <td>smart_&lt;attribute&gt;_value:&lt;hdd&gt;</td>
  <td>uint8_t</td>
  <td>GAUGE</td>
  <td>Текущее нормализованное значение атрибута SMART.</td>
</tr>
<tr>
  <td>smart_&lt;attribute&gt;_worst:&lt;hdd&gt;</td>
  <td>uint8_t</td>
  <td>GAUGE</td>
  <td>Наихудшее (минимальное) нормализованное значение атрибута SMART, зафиксированное
за все время эксплуатации диска.</td>
</tr>
<tr>
  <td>smart_&lt;attribute&gt;_thresh:&lt;hdd&gt;</td>
  <td>uint8_t</td>
  <td>GAUGE</td>
  <td>Предельно допустимое нормализованное значение атрибута SMART. Ситуация, когда
текущее нормализованное значение атрибута меньше либо равно предельно допустимому
нормализованному значению атрибута, означает близость выхода диска из строя.</td>
</tr>
<tr>
  <td>smart_&lt;attribute&gt;_raw:&lt;hdd&gt;</td>
  <td>uint64_t (значимы 48 младших бит)</td>
  <td>зависит от атрибута</td>
  <td>Текущее сырое значение атрибута SMART.</td>
</tr>
<tr>
  <td>smart_spinup_time:&lt;hdd&gt;</td>
  <td>uint16_t</td>
  <td>GAUGE</td>
  <td>Текущее время раскрутки шпинделя диска в миллисекундах. Возвращается только в том
случае, если запрошен атрибут SMART с номером 3. Диск может не поддерживать это значение.</td>
</tr>
<tr>
  <td>smart_spinup_time_avg:&lt;hdd&gt;</td>
  <td>uint16_t</td>
  <td>GAUGE</td>
  <td>Среднее время раскрутки шпинделя диска в миллисекундах. Возвращается только в том
случае, если запрошен атрибут SMART с номером 3. Диск может не поддерживать это значение.</td>
</tr>
<tr>
  <td>smart_temp:&lt;hdd&gt;</td>
  <td>uint16_t</td>
  <td>GAUGE</td>
  <td>Текущая температура диска в градусах Цельсия. Возвращается только в том случае, если
запрошен атрибут SMART с номером 194.</td>
</tr>
<tr>
  <td>smart_temp_min:&lt;hdd&gt;</td>
  <td>uint16_t</td>
  <td>GAUGE</td>
  <td>Минимальная температура диска в градусах Цельсия, которая была зафиксирована за все
время эксплуатации диска. Возвращается только в том случае, если запрошен атрибут SMART с
номером 194. Диск может не поддерживать это значение.</td>
</tr>
<tr>
  <td>smart_temp_max:&lt;hdd&gt;</td>
  <td>uint16_t</td>
  <td>GAUGE</td>
  <td>Максимальная температура диска в градусах Цельсия, которая была зафиксирована за все
время эксплуатации диска. Возвращается только в том случае, если запрошен атрибут SMART с
номером 194. Диск может не поддерживать это значение.</td>
</tr>
<tr>
  <td>smart_failed:&lt;hdd&gt;</td>
  <td>uint8_t</td>
  <td>GAUGE</td>
  <td>Статус SMART. Вычисляется по всем атрибутам SMART независимо от того, какие из атрибутов
были фактически запрошены. Может принимать одно из трех значений: 0 &mdash; никакие из
атрибутов SMART не выходят сейчас и не выходили в прошлом за предельно допустимые значения;
1 &mdash; хотя бы один атрибут SMART в прошлом выходил за предельно допустимое значение;
2 &mdash; хотя бы один атрибут SMART в настоящий момент выходит за предельно допустимое
значение.</td>
</tr>
</table>

<div><tt>&lt;hdd&gt;</tt> &mdash; имя жесткого диска в системе.</div>
<div><tt>&lt;attribute&gt;</tt> &mdash; десятичный номер атрибута SMART от 0 до 255.</div>
</div>

<h3 class="man-title"><a name="cmd_socket"><tt>SOCKET</tt></a></h3>
<div class="man-body">
Возвращает статистику сокетов. Подробности использования команды описаны в
разделе <a href="#cfg_socket">Файл конфигурации</a>.
</div>

<h3 class="man-title"><a name="cmd_swap"><tt>SWAP</tt></a></h3>
<div class="man-body">
Возвращает факт существования свопа и статистику его использования: число операций выгрузки
страниц в своп и их загрузки из свопа, а также число выгруженных и загруженных страниц.

<table class="p data">
<tr>
  <th>Имя переменной</th>
  <th>Тип возвращаемого значения<br>в терминах языка C</th>
  <th>Тип возвращаемого значения<br>в терминах RRDTool</th>
  <th>Описание</th>
</tr>
<tr>
  <td>swap_exists</td>
  <td>uint8_t (значим 1 младший бит)</td>
  <td>GAUGE</td>
  <td>Флаг, показывающий, что операционная система имеет хотя бы один активный раздел
для свопа (1) или не имеет ни одного (0).</td>
</tr>
<tr>
  <td>swap_operations_out</td>
  <td>unsigned long long</td>
  <td>COUNTER</td>
  <td>Число операций выгрузки страниц в своп.</td>
</tr>
<tr>
  <td>swap_operations_in</td>
  <td>unsigned long long</td>
  <td>COUNTER</td>
  <td>Число операций загрузки страниц из свопа.</td>
</tr>
<tr>
  <td>swap_pages_out</td>
  <td>unsigned long long</td>
  <td>COUNTER</td>
  <td>Число страниц, выгруженных в своп.</td>
</tr>
<tr>
  <td>swap_pages_in</td>
  <td>unsigned long long</td>
  <td>COUNTER</td>
  <td>Число страниц, загруженных из свопа.</td>
</tr>
</table>
</div>

<h3 class="man-title"><a name="cmd_sysctl"><tt>SYSCTL &lt;variable&gt;</tt></a></h3>
<div class="man-body">
Возвращает значение переменной sysctl с именем <tt>&lt;variable&gt;</tt>. Переменная должна
быть целочисленного или строкового типа. Поддерживается до 128 команд <tt>SYSCTL</tt>.

<table class="p data">
<tr>
  <th>Имя переменной</th>
  <th>Тип возвращаемого значения<br>в терминах языка C</th>
  <th>Тип возвращаемого значения<br>в терминах RRDTool</th>
  <th>Описание</th>
</tr>
<tr>
  <td>sysctl_&lt;variable&gt;</td>
  <td>Зависит от переменной</td>
  <td>Зависит от переменной</td>
  <td>Значение переменной sysctl.</td>
</tr>
</table>
</div>

<h3 class="man-title"><a name="cmd_time"><tt>TIME &lt;time&gt;</tt></a></h3>
<div class="man-body">
Команда сообщает демону <tt>ussd</tt> текущее время <tt>&lt;time&gt;</tt> на сервере
мониторинга в формате <tt>time_t</tt>. <tt>ussd</tt> запоминает это время и использует
его при возврате серверу мониторинга любой статистики. С точки зрения сервера мониторинга
полученная им статистика будет привязана к его собственному времени, а не ко времени на
сервере с демоном <tt>ussd</tt>, несмотря на то, что в действительности время на двух
серверах может сильно различаться. Использование данной команды рекомендуется в каждом
запросе, т.к. повышает точность получения статистики сервером мониторинга. Если команда
не используется, то вся возвращаемая серверу мониторинга статистика будет привязана ко
времени на сервере с демоном <tt>ussd</tt>. Алгоритм привязки статистики демоном
<tt>ussd</tt> ко времени на сервере мониторинга устойчив к переводу времени на сервере
с демоном <tt>ussd</tt>.

<p>Команда возвращает текущее время на сервере с демоном <tt>ussd</tt>, а также разницу
между временем на сервере с демоном <tt>ussd</tt> и временем на сервере мониторинга.

<table class="p data">
<tr>
  <th>Имя переменной</th>
  <th>Тип возвращаемого значения<br>в терминах языка C</th>
  <th>Тип возвращаемого значения<br>в терминах RRDTool</th>
  <th>Описание</th>
</tr>
<tr>
  <td>time</td>
  <td>unsigned long</td>
  <td>&ndash;</td>
  <td>Время на сервере с демоном <tt>ussd</tt> в формате <tt>time_t</tt> в момент возврата
переменной.</td>
</tr>
<tr>
  <td>timediff</td>
  <td>long</td>
  <td>GAUGE</td>
  <td>Разница в секундах между временем на сервере с демоном <tt>ussd</tt> и временем на
сервере мониторинга. Если значение переменной положительное, то время на сервере с
демоном <tt>ussd</tt> опережает время на сервере мониторинга. Если значение переменной
отрицательное, то время на сервере с демоном <tt>ussd</tt> отстает от времени на сервере
мониторинга.</td>
</tr>
</table>
</div>

<h3 class="man-title"><a name="cmd_uname"><tt>UNAME</tt></a></h3>
<div class="man-body">
Возвращает название и версию операционной системы, информацию о типе процессора, дату
компиляции ядра и имя конфигурационного файла ядра.

<table class="p data">
<tr>
  <th>Имя переменной</th>
  <th>Тип возвращаемого значения<br>в терминах языка C</th>
  <th>Тип возвращаемого значения<br>в терминах RRDTool</th>
  <th>Описание</th>
</tr>
<tr>
  <td>machine</td>
  <td>char[]</td>
  <td>&ndash;</td>
  <td>Тип процессора. Значение аналогично результату вызова <tt>uname -p</tt>.</td>
</tr>
<tr>
  <td>os_name</td>
  <td>char[]</td>
  <td>&ndash;</td>
  <td>Название операционной системы. Значение аналогично результату вызова
<tt>uname -s</tt>.</td>
</tr>
<tr>
  <td>os_release</td>
  <td>char[]</td>
  <td>&ndash;</td>
  <td>Номер и тэг версии операционной системы. Значение аналогично результату вызова
<tt>uname -r</tt>.</td>
</tr>
<tr>
  <td>os_version</td>
  <td>char[]</td>
  <td>&ndash;</td>
  <td>Подробная информация о версии операционной системы, дате компиляции ядра и имени
конфигурационного файла ядра. Значение аналогично результату вызова <tt>uname -v</tt>.</td>
</tr>
</table>
</div>

<h3 class="man-title"><a name="cmd_uptime"><tt>UPTIME</tt></a></h3>
<div class="man-body">
Возвращает время работы системы, а также среднее число одновременно работающих процессов
в системе в течение последней минуты, 5 минут и 15 минут.

<table class="p data">
<tr>
  <th>Имя переменной</th>
  <th>Тип возвращаемого значения<br>в терминах языка C</th>
  <th>Тип возвращаемого значения<br>в терминах RRDTool</th>
  <th>Описание</th>
</tr>
<tr>
  <td>uptime</td>
  <td>unsigned long</td>
  <td>COUNTER</td>
  <td>Время работы системы в секундах с момента загрузки.</td>
</tr>
<tr>
  <td>load1</td>
  <td>double (%.2f)</td>
  <td>GAUGE</td>
  <td>Среднее число одновременно работающих процессов в системе в течение последней
минуты.</td>
</tr>
<tr>
  <td>load5</td>
  <td>double (%.2f)</td>
  <td>GAUGE</td>
  <td>Среднее число одновременно работающих процессов в системе в течение последних
5 минут.</td>
</tr>
<tr>
  <td>load15</td>
  <td>double (%.2f)</td>
  <td>GAUGE</td>
  <td>Среднее число одновременно работающих процессов в системе в течение последних
15 минут.</td>
</tr>
</table>
</div>

<h3 class="man-title"><a name="cmd_version"><tt>VERSION</tt></a></h3>
<div class="man-body">
Возвращает номер версии <tt>ussd</tt>.

<table class="p data">
<tr>
  <th>Имя переменной</th>
  <th>Тип возвращаемого значения<br>в терминах языка C</th>
  <th>Тип возвращаемого значения<br>в терминах RRDTool</th>
  <th>Описание</th>
</tr>
<tr>
  <td>version</td>
  <td>unsigned long (%u%02u%02u)</td>
  <td>GAUGE</td>
  <td>Номер версии <tt>ussd</tt>. Представляет собой целое число, составленное из трех частей:
старший номер версии, младший номер версии (2 цифры) и номер ревизии (2 цифры).</td>
</tr>
</table>
</div>

<h3 class="man-title"><a name="cmd_vmstat"><tt>VMSTAT</tt></a></h3>
<div class="man-body">
Возвращает счетчики состояний процессора, по которым можно рассчитать средний рейтинг
занятости процессора в процентах. Например, средний рейтинг занятости процессора при
обработке прерываний рассчитывается по формуле:

<pre>приращение(cp_intr) / приращение(cp_total) * 100</pre>

<p>Средний рейтинг общей занятости процессора рассчитывается по формуле:

<pre>(приращение(cp_user) + приращение(cp_nice) + приращение(cp_sys) + приращение(cp_intr)) / приращение(cp_total) * 100</pre>

<table class="p data">
<tr>
  <th>Имя переменной</th>
  <th>Тип возвращаемого значения<br>в терминах языка C</th>
  <th>Тип возвращаемого значения<br>в терминах RRDTool</th>
  <th>Описание</th>
</tr>
<tr>
  <td>cp_user</td>
  <td>unsigned long</td>
  <td>COUNTER</td>
  <td>Количество тиков процессора, проведенных в состоянии CP_USER.</td>
</tr>
<tr>
  <td>cp_nice</td>
  <td>unsigned long</td>
  <td>COUNTER</td>
  <td>Количество тиков процессора, проведенных в состоянии CP_NICE.</td>
</tr>
<tr>
  <td>cp_sys</td>
  <td>unsigned long</td>
  <td>COUNTER</td>
  <td>Количество тиков процессора, проведенных в состоянии CP_SYS.</td>
</tr>
<tr>
  <td>cp_intr</td>
  <td>unsigned long</td>
  <td>COUNTER</td>
  <td>Количество тиков процессора, проведенных в состоянии CP_INTR.</td>
</tr>
<tr>
  <td>cp_idle</td>
  <td>unsigned long</td>
  <td>COUNTER</td>
  <td>Количество тиков процессора, проведенных в состоянии CP_IDLE.</td>
</tr>
<tr>
  <td>cp_total</td>
  <td>unsigned long</td>
  <td>COUNTER</td>
  <td>Суммарное количество тиков по всем 5 состояниям процессора.</td>
</tr>
</table>
</div>

<p>&mdash;<br>
Данный документ написан и поддерживается в актуальном состоянии группой мониторинга
&lt;<a href="mailto:monitoring@rambler-co.ru">monitoring@rambler-co.ru</a>&gt;.
</body>
</html>
